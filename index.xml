<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ryan&#39;s Blog on Ryan&#39;s Blog</title>
    <link>https://RyanAdex.github.io/</link>
    <description>Recent content in Ryan&#39;s Blog on Ryan&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Sun, 15 Oct 2017 00:00:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LeetCode 队列与BFS--岛屿的数量</title>
      <link>https://RyanAdex.github.io/2018/12/09/queue/</link>
      <pubDate>Sun, 09 Dec 2018 20:29:13 +0800</pubDate>
      
      <guid>https://RyanAdex.github.io/2018/12/09/queue/</guid>
      <description>

&lt;h1 id=&#34;岛屿的个数&#34;&gt;岛屿的个数&lt;/h1&gt;

&lt;p&gt;给定一个由 &amp;lsquo;1&amp;rsquo;（陆地）和 &amp;lsquo;0&amp;rsquo;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。
示例1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入:
11110
11010
11000
00000

输出: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例2：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入:
11000
11000
00100
00011

输出: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;分析&#34;&gt;分析&lt;/h1&gt;

&lt;p&gt;这道题的解法有很多，但本帖用广度优先搜索&lt;code&gt;BFS&lt;/code&gt;来解答。
本题输入是一个二维数组，判断一个岛屿的要素是判断是否该陆地（1）&lt;code&gt;上下左右&lt;/code&gt;是否被水（0）包围，也就是说，岛屿的数量=联通陆地（1）的数量。
&lt;code&gt;BFS&lt;/code&gt;算法题解如下，通过找到为岛（1）的初始点，然后对临近的岛屿进行依次访问，利用队列对访问的岛屿进行储存，如下列图示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  +-----&amp;gt;
 +-+
++1|1 1 1 0
+--+
| 1 1 0 1 0
|
v 1 1 0 0 0

  0 0 0 0 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当找到初始（1）的时候，将其坐标入队，依据队列的&lt;code&gt;FIFO&lt;/code&gt;特性，从队列中取出坐标，对其坐标的&lt;code&gt;上下左右&lt;/code&gt;元素进行访问，如果临近的元素为陆地（1），则将其坐标加入队列中等待访问，如果该元素已经被访问，则跳过，重复这一过程，直到队列为空，说明元素周围再也没有陆地，便可看作岛屿。访问过的（1）认为的变为（0）便于后续对未访问的陆地进行查找,岛屿的数量就等于队列为空的遍历次数。其代码如下：&lt;/p&gt;

&lt;h2 id=&#34;c-实现&#34;&gt;C++实现&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
private:
        queue&amp;lt;int&amp;gt; que;
        int count=0;

        int x=0;
        int y=0;
        int xx=0;
        int yy=0;
public:
    int numIslands(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid) {
        int rows=grid.size();
        int cols=rows&amp;gt;0?grid[0].size():0;
        int dx[]={-1,0,1,0};
        int dy[]={0,1,0,-1};
        if(rows==0||cols==0){
            return 0;
        }
        for(int i=0;i&amp;lt;rows;i++){
            for(int j=0;j&amp;lt;cols;j++){
                //cout&amp;lt;&amp;lt;rows&amp;lt;&amp;lt;cols&amp;lt;&amp;lt;endl;//外部两个for循环为从上到下从左到右寻找未访问的陆地，因为访问过的陆地都已经被置零
                if(grid[i][j]==&#39;1&#39;){
                    que.push(i);
                    que.push(j); 
                    grid[i][j]=&#39;0&#39;;
                    while(!que.empty()){
                        x=que.front();
                        que.pop();
                        y=que.front();
                        que.pop();
                        for(int k=0;k&amp;lt;4;k++){
                            xx=x+dx[k];
                            yy=y+dy[k];
                            if(xx&amp;lt;0||xx&amp;gt;=rows||yy&amp;lt;0||yy&amp;gt;=cols){
                                continue;
                            }
                        
                            if(grid[xx][yy]==&#39;1&#39;){
                                grid[xx][yy]=&#39;0&#39;;
                                que.push(xx);
                                que.push(yy);
                            }
                        }
                    }
                    count++;//队列为空的次数=岛屿的数量
                }
            }
        }

        return count;
    }

};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;go实现&#34;&gt;Go实现&lt;/h2&gt;

&lt;p&gt;由于go语言没有队列&lt;code&gt;queue&lt;/code&gt;包，我们自己建一个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package queue

//Item any type&#39;s item
type Item interface {
}

//ItemQueue is store items
type ItemQueue struct {
    items []Item
}

//ItemQueuer is a interface
type ItemQueuer interface {
    New() ItemQueue
    Push(t Item)
    Pop() *Item
    Empty() bool
    Size() int
}

//Push a new item
func (s *ItemQueue) Push(t Item) {
    s.items = append(s.items, t)
}

//Pop a front item
func (s *ItemQueue) Pop() {
    s.items = s.items[1:]
}

//Empty of items
func (s *ItemQueue) Empty() bool {
    return len(s.items) == 0
}

//Size of items
func (s *ItemQueue) Size() int {
    return len(s.items)
}

//Front of items
func (s *ItemQueue) Front() Item {
    return s.items[0]
}

//Back of items
func (s *ItemQueue) Back() Item {
    return s.items[len(s.items)-1]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们用接口实现了类似&lt;code&gt;C++&lt;/code&gt;泛型的&lt;code&gt;queue&lt;/code&gt;类，下面是&lt;code&gt;go语言&lt;/code&gt;实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;self/queue&amp;quot;
    &amp;quot;time&amp;quot;
)

var que queue.ItemQueue//生命一个队列变量

var m = [][]byte{
    {&#39;1&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;},
    {&#39;1&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;},
    {&#39;1&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;1&#39;},
    {&#39;0&#39;, &#39;0&#39;, &#39;1&#39;, &#39;1&#39;, &#39;0&#39;},
}

func main() {
    start := time.Now()
    coun := numIslands(m)
    fmt.Printf(&amp;quot;the num of isl is %v&amp;quot;, coun)
    cost := time.Since(start)
    fmt.Printf(&amp;quot;Cost %s&amp;quot;, cost)
}
func numIslands(grid [][]byte) int {
    var que queue.ItemQueue
    var x, y, xx, yy, count, rows, cols int = 0, 0, 0, 0, 0, 0, 0
    rows = len(grid)
    if rows &amp;gt; 0 {
        cols = len(grid[0])
    } else {
        cols = 0
    }
    var dx, dy = []int{-1, 0, 1, 0}, []int{0, 1, 0, -1}
    if rows == 0 || cols == 0 {
        return 0
    }
    for i := 0; i &amp;lt; rows; i++ {
        for j := 0; j &amp;lt; cols; j++ {
            if grid[i][j] == &#39;1&#39; {
                que.Push(i)
                que.Push(j)
                grid[i][j] = &#39;0&#39;
                for !que.Empty() {
                    x = que.Front().(int)//因为储存的是坐标，所以是int，这里要强制转化，因为que.Front()返回的是interface{}类型
                    que.Pop()
                    y = que.Front().(int)
                    que.Pop()
                    for k := 0; k &amp;lt; 4; k++ {
                        xx = x + dx[k]
                        yy = y + dy[k]
                        if xx &amp;lt; 0 || xx &amp;gt;= rows || yy &amp;lt; 0 || yy &amp;gt;= cols {
                            continue
                        }
                        if grid[xx][yy] == &#39;1&#39; {
                            grid[xx][yy] = &#39;0&#39;
                            que.Push(xx)
                            que.Push(yy)
                        }
                    }
                }
                count++
            }
        }
    }
    return count
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>go语言带cookie的net客户端请求ii与[]byte转string</title>
      <link>https://RyanAdex.github.io/2018/12/04/htmlparse/</link>
      <pubDate>Tue, 04 Dec 2018 20:29:47 +0800</pubDate>
      
      <guid>https://RyanAdex.github.io/2018/12/04/htmlparse/</guid>
      <description>&lt;p&gt;前些日子参加了一个叫&lt;a href=&#34;https://adventofcode.com&#34; target=&#34;_blank&#34;&gt;Advent of Code&lt;/a&gt;的编程大赛，每天一道题，快活似神仙。这每道题都有自己的拼图数据输入&lt;code&gt;puzzle input&lt;/code&gt;，要做题就需要用到该数据，把数据复制过来感觉又太麻烦，于是就兴起写了一个直接从html读取数据的函数。
其&lt;a href=&#34;https://adventofcode.com/2018/day/1/input&#34; target=&#34;_blank&#34;&gt;数据&lt;/a&gt;如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+12
-10
-4
-8
+18
-1
-13
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看标准库文档，发现&lt;code&gt;net/html&lt;/code&gt;包可以做这个功能，其函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;resp, err := http.Get(&amp;quot;http://example.com/&amp;quot;)
if err != nil {
    // handle error
}
defer resp.Body.Close()
body, err := ioutil.ReadAll(resp.Body)
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后调试，但并未有相关数据输出，在浏览器中&lt;code&gt;检查元素&lt;/code&gt;发现该请求需要带&lt;code&gt;cookie&lt;/code&gt;才能正确返回数据。直接使用&lt;code&gt;http.Get()&lt;/code&gt;并不带有&lt;code&gt;cookie&lt;/code&gt;，所以改用&lt;code&gt;NewRequest&lt;/code&gt;使用指定的方法、网址和可选的主题创建并返回一个新的&lt;code&gt;*Request&lt;/code&gt;。其函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;client := &amp;amp;http.Client{}
    req, err := http.NewRequest(&amp;quot;GET&amp;quot;, url, nil)
    if err != nil {
        log.Fatal(err)
    }
    req.Header.Set(&amp;quot;Cookie&amp;quot;, &amp;quot;name=value&amp;quot;)
    resp, err := client.Do(req)

    robots, err := ioutil.ReadAll(resp.Body)


  resp.Body.Close()//必须要关闭Body
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用&lt;code&gt;ioutil.ReadAll()&lt;/code&gt;返回的是&lt;code&gt;[]byte&lt;/code&gt;类型，入需要使用可以先将&lt;code&gt;[]byte&lt;/code&gt;转换成&lt;code&gt;string&lt;/code&gt;，Go语言初学者都会的类型转换语法：&lt;code&gt;string(b)&lt;/code&gt;，Go为了稳定性对于上述方法需要经过一些数据上的复制，一旦数据量过大，这个成本是难以忍受的。
 所以为了让Go服帖，我们得用上&lt;code&gt;unsafe&lt;/code&gt;包，&lt;code&gt;unsafe&lt;/code&gt;包提供一些可以跳过Go语言类型安全限制的操作。看下面代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func BytesString(b []byte) string {
    return *(*string)(unsafe.Pointer(&amp;amp;b))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们取到&lt;code&gt;[]byte&lt;/code&gt;的指针，Go会说&lt;code&gt;*byte&lt;/code&gt;不是&lt;code&gt;*string&lt;/code&gt;，但是我们有外挂&lt;code&gt;unsafe.Pointer&lt;/code&gt;，所以Go就通过了，接着你很自在的把&lt;code&gt;*byte&lt;/code&gt;转成了&lt;code&gt;*string&lt;/code&gt;，因为&lt;code&gt;reflect.StringHeader&lt;/code&gt;和&lt;code&gt;reflect.SliceHeader&lt;/code&gt;的结构体只相差末尾一个字段。
 类似的用法可以看&lt;a href=&#34;https://zhuanlan.zhihu.com/p/20010926&#34; target=&#34;_blank&#34;&gt;Go语言黑魔法&lt;/a&gt;
 接着用&lt;code&gt;regexp&lt;/code&gt;包正则表达式&lt;code&gt;FindAllString&lt;/code&gt;取出匹配的&lt;code&gt;[]string&lt;/code&gt;数据使用，然后再用&lt;code&gt;strconv.Atoi()&lt;/code&gt;进行转化就可以了。
 Day1的题为求和，其代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;regexp&amp;quot;
    &amp;quot;strconv&amp;quot;
    &amp;quot;unsafe&amp;quot;
)

func BytesString(b []byte) string {//[]byte 转string
    return *(*string)(unsafe.Pointer(&amp;amp;b))
}

func getPuzzle(url string) string {//从网页抓取数据
    client := &amp;amp;http.Client{}
    req, err := http.NewRequest(&amp;quot;GET&amp;quot;, url, nil)
    if err != nil {
        log.Fatal(err)
    }
    req.Header.Set(&amp;quot;Cookie&amp;quot;, &amp;quot;session=53616c74...&amp;quot;)
    resp, err := client.Do(req)

    robots, err := ioutil.ReadAll(resp.Body)
    // robots := bufio.NewReader(resp.Body)

    resp.Body.Close()
    str := BytesString(robots)
    // fmt.Printf(&amp;quot;%q&amp;quot;, str)
    return str
    // io.Copy(os.Stdout, resp.Body)
}
func sum(num []int) int {
    sum := 0
    for _, n := range num {
        sum += n
    }
    return sum
}
func strtoint(str []string) []int {//string转int
    num := make([]int, len(str))
    for i := 0; i &amp;lt; len(str); i++ {
        flag := str[i][0]
        chafre, _ := strconv.Atoi(str[i][1:])
        switch flag {
        case &#39;+&#39;:
            num[i] = chafre
        case &#39;-&#39;:
            num[i] = -chafre
        }
    }
    return num
}
func main() {
    change := getPuzzle(&amp;quot;https://adventofcode.com/2018/day/1/input&amp;quot;)
    re := regexp.MustCompile(&amp;quot;[+|-][0-9]*&amp;quot;)//正则表达式
    str := re.FindAllString(change, -1)

    num := strtoint(str)

    sum := sum(num)
    fmt.Printf(&amp;quot;sum is %d\n&amp;quot;, sum)


}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果有更好的方法，欢迎私信，哈哈哈···&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go语言 os.Rename() cannot move the file to a different disk drive 怎么办</title>
      <link>https://RyanAdex.github.io/2018/11/28/filemove/</link>
      <pubDate>Wed, 28 Nov 2018 13:28:46 +0800</pubDate>
      
      <guid>https://RyanAdex.github.io/2018/11/28/filemove/</guid>
      <description>&lt;p&gt;时值我小病在家休养生息，喜欢跳广场舞的外公来寻求我的帮助，他们跳广场舞是将存有歌曲的U盘插到音响上面，而音响大部分都是只能显示歌曲的索引&lt;code&gt;index&lt;/code&gt;，不能直接显示歌曲名，所以为了方便他们会在U盘里面对歌曲进行排序。由于音响是寻址按顺序播放，意思就是在U盘里面的歌曲需要一首一首的按顺序复制过去，而且当对U盘歌曲进行增添的时候又需要按照顺序重新复制一遍，可以说相当麻烦。&lt;strong&gt;为了将我从这重复的劳动中解放出来&lt;/strong&gt;，我用go语言写了一个小工具，本来想着分分钟写完，却没想到踩到了坑。
在&lt;code&gt;os&lt;/code&gt;包中有一个&lt;code&gt;Rename()&lt;/code&gt;函数具有重命名和移动的功能，其函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Rename(oldpath, newpath string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rename修改一个文件的名字，移动一个文件。可能会有一些个操作系统特定的限制。&lt;/p&gt;

&lt;p&gt;在windows系统下面使用该函数，&lt;code&gt;oldpath&lt;/code&gt;和&lt;code&gt;newpath&lt;/code&gt;在同一个磁盘/卷下面能正常使用，可我需要将音乐移动到U盘上，当使用这个函数的时候出现了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;The system cannot move the file to a different disk drive.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搜索&lt;code&gt;Github&lt;/code&gt;的&lt;a href=&#34;https://github.com/golang/go/issues/13766&#34; target=&#34;_blank&#34;&gt;issues&lt;/a&gt;，发现Rename在windows中不能进行跨磁盘/卷操作。
为了实现跨磁盘/卷操作，一种方法是直接调用&lt;code&gt;windows API&lt;/code&gt;，于是在&lt;a href=&#34;https://docs.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-movefile&#34; target=&#34;_blank&#34;&gt;windows api docs&lt;/a&gt;中搜索到&lt;code&gt;movefileex()&lt;/code&gt;函数能够实现该功能，但是在go语言的&lt;code&gt;syscall&lt;/code&gt;包中只有&lt;code&gt;movefile()&lt;/code&gt;函数，其函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func MoveFile(from *uint16, to *uint16) (err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现文件移动的函数可以写成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func movefile(oldpath, newpath string) error { //跨卷移动
    from, err := syscall.UTF16PtrFromString(oldpath)
    if err != nil {
        return err
    }
    to, err := syscall.UTF16PtrFromString(newpath)
    if err != nil {
        return err
    }
    return syscall.MoveFile(from, to)//windows API

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们读取&lt;code&gt;oldpath&lt;/code&gt;目录里面的文件时调用&lt;code&gt;io/ioutil&lt;/code&gt;包的&lt;code&gt;ReadDir()&lt;/code&gt;函数可按照文件夹内的排序方式批量读入文件名，其函数实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func filenamelist(filepath string) []string {
    var list []string
    rd, err := ioutil.ReadDir(filepath) //遍历目录
    if err != nil {
        log.Fatal(err)
    }
    for _, fi := range rd {
        if fi.IsDir() {
            fmt.Printf(&amp;quot;[%s]is dir\n&amp;quot;, fi.Name())

        } else {
            list = append(list, fi.Name())
            fmt.Println(filepath + fi.Name())
        }
    }
    return list//返回一个string数组

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然也可以普通方式读入文件名然后用&lt;code&gt;sort&lt;/code&gt;包进行排序。
下面是完整代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;syscall&amp;quot;
)

func movefile(oldpath, newpath string) error { //跨卷移动
    from, err := syscall.UTF16PtrFromString(oldpath)
    if err != nil {
        return err
    }
    to, err := syscall.UTF16PtrFromString(newpath)
    if err != nil {
        return err
    }
    return syscall.MoveFile(from, to)//windows API

}
func filenamelist(filepath string) []string {
    var list []string
    rd, err := ioutil.ReadDir(filepath) //遍历目录
    if err != nil {
        log.Fatal(err)
    }
    for _, fi := range rd {
        if fi.IsDir() {
            fmt.Printf(&amp;quot;[%s]is dir\n&amp;quot;, fi.Name())

        } else {
            list = append(list, fi.Name())
            fmt.Println(filepath + fi.Name())
        }
    }
    return list

}
func movefilelist(oldpath, newpath string) {
    for _, fi := range filenamelist(oldpath) { //移动目录的所有文件
        err := movefile(oldpath+fi, newpath+fi)
        if err != nil {
            log.Fatal(err)
        }
        fmt.Println(fi + &amp;quot;--Move To --&amp;gt;&amp;quot; + newpath + &amp;quot;--OK!&amp;quot;)

    }
}
func main() {
    movefilelist(os.Args[1], os.Args[2])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后在终端中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Ryan@DESKTO MINGW64 /Go/test (master)
$ go run main.go ~/Desktop/music/ /d/
C:/Users/Ryan/Desktop/music/新建文本文档 (2).txt
C:/Users/Ryan/Desktop/music/新建文本文档.txt
新建文本文档 (2).txt--Move To --&amp;gt;D:/--OK!
新建文本文档.txt--Move To --&amp;gt;D:/--OK!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这个脚本，我今后终于可以愉快的帮助我外公了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;转载请注明&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Example Page</title>
      <link>https://RyanAdex.github.io/tutorial/example/</link>
      <pubDate>Sun, 09 Sep 2018 00:00:00 +0800</pubDate>
      
      <guid>https://RyanAdex.github.io/tutorial/example/</guid>
      <description>

&lt;p&gt;In this tutorial, I&amp;rsquo;ll share my top 10 tips for getting started with Academic:&lt;/p&gt;

&lt;h2 id=&#34;tip-1&#34;&gt;Tip 1&lt;/h2&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;tip-2&#34;&gt;Tip 2&lt;/h2&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
