[{"authors":null,"categories":null,"content":"This feature can be used for publishing content such as:\n Project or software documentation Online courses Tutorials  The parent folder may be renamed, for example, to docs for project documentation or course for creating an online course.\nTo disable this feature, either delete the parent folder, or set draft = true in the front matter of all its pages.\nAfter renaming or deleting the parent folder, you may wish to update any [[menu.main]] menu links to it in the config.toml.\n","date":1536422400,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1536422400,"objectID":"c3224f3a64174f08aaf31e1f1d16ffd3","permalink":"https://RyanAdex.github.io/tutorial/","publishdate":"2018-09-09T00:00:00+08:00","relpermalink":"/tutorial/","section":"tutorial","summary":"This feature can be used for publishing content such as:\n Project or software documentation Online courses Tutorials  The parent folder may be renamed, for example, to docs for project documentation or course for creating an online course.\nTo disable this feature, either delete the parent folder, or set draft = true in the front matter of all its pages.\nAfter renaming or deleting the parent folder, you may wish to update any [[menu.","tags":null,"title":"Overview","type":"docs"},{"authors":null,"categories":[],"content":" 岛屿的个数 给定一个由 \u0026lsquo;1\u0026rsquo;（陆地）和 \u0026lsquo;0\u0026rsquo;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例1：\n输入: 11110 11010 11000 00000 输出: 1  示例2：\n输入: 11000 11000 00100 00011 输出: 3  分析 这道题的解法有很多，但本帖用广度优先搜索BFS来解答。 本题输入是一个二维数组，判断一个岛屿的要素是判断是否该陆地（1）上下左右是否被水（0）包围，也就是说，岛屿的数量=联通陆地（1）的数量。 BFS算法题解如下，通过找到为岛（1）的初始点，然后对临近的岛屿进行依次访问，利用队列对访问的岛屿进行储存，如下列图示:\n +-----\u0026gt; +-+ ++1|1 1 1 0 +--+ | 1 1 0 1 0 | v 1 1 0 0 0 0 0 0 0 0  当找到初始（1）的时候，将其坐标入队，依据队列的FIFO特性，从队列中取出坐标，对其坐标的上下左右元素进行访问，如果临近的元素为陆地（1），则将其坐标加入队列中等待访问，如果该元素已经被访问，则跳过，重复这一过程，直到队列为空，说明元素周围再也没有陆地，便可看作岛屿。访问过的（1）认为的变为（0）便于后续对未访问的陆地进行查找,岛屿的数量就等于队列为空的遍历次数。其代码如下：\nC++实现 class Solution { private: queue\u0026lt;int\u0026gt; que; int count=0; int x=0; int y=0; int xx=0; int yy=0; public: int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int rows=grid.size(); int cols=rows\u0026gt;0?grid[0].size():0; int dx[]={-1,0,1,0}; int dy[]={0,1,0,-1}; if(rows==0||cols==0){ return 0; } for(int i=0;i\u0026lt;rows;i++){ for(int j=0;j\u0026lt;cols;j++){ //cout\u0026lt;\u0026lt;rows\u0026lt;\u0026lt;cols\u0026lt;\u0026lt;endl;//外部两个for循环为从上到下从左到右寻找未访问的陆地，因为访问过的陆地都已经被置零 if(grid[i][j]=='1'){ que.push(i); que.push(j); grid[i][j]='0'; while(!que.empty()){ x=que.front(); que.pop(); y=que.front(); que.pop(); for(int k=0;k\u0026lt;4;k++){ xx=x+dx[k]; yy=y+dy[k]; if(xx\u0026lt;0||xx\u0026gt;=rows||yy\u0026lt;0||yy\u0026gt;=cols){ continue; } if(grid[xx][yy]=='1'){ grid[xx][yy]='0'; que.push(xx); que.push(yy); } } } count++;//队列为空的次数=岛屿的数量 } } } return count; } };  Go实现 由于go语言没有队列queue包，我们自己建一个：\npackage queue //Item any type's item type Item interface { } //ItemQueue is store items type ItemQueue struct { items []Item } //ItemQueuer is a interface type ItemQueuer interface { New() ItemQueue Push(t Item) Pop() *Item Empty() bool Size() int } //Push a new item func (s *ItemQueue) Push(t Item) { s.items = append(s.items, t) } //Pop a front item func (s *ItemQueue) Pop() { s.items = s.items[1:] } //Empty of items func (s *ItemQueue) Empty() bool { return len(s.items) == 0 } //Size of items func (s *ItemQueue) Size() int { return len(s.items) } //Front of items func (s *ItemQueue) Front() Item { return s.items[0] } //Back of items func (s *ItemQueue) Back() Item { return s.items[len(s.items)-1] }  我们用接口实现了类似C++泛型的queue类，下面是go语言实现：\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;self/queue\u0026quot; \u0026quot;time\u0026quot; ) var que queue.ItemQueue//生命一个队列变量 var m = [][]byte{ {'1', '1', '0', '1', '0'}, {'1', '1', '0', '1', '0'}, {'1', '1', '0', '1', '1'}, {'0', '0', '1', '1', '0'}, } func main() { start := time.Now() coun := numIslands(m) fmt.Printf(\u0026quot;the num of isl is %v\u0026quot;, coun) cost := time.Since(start) fmt.Printf(\u0026quot;Cost %s\u0026quot;, cost) } func numIslands(grid [][]byte) int { var que queue.ItemQueue var x, y, xx, yy, count, rows, cols int = 0, 0, 0, 0, 0, 0, 0 rows = len(grid) if rows \u0026gt; 0 { cols = len(grid[0]) } else { cols = 0 } var dx, dy = []int{-1, 0, 1, 0}, []int{0, 1, 0, -1} if rows == 0 || cols == 0 { return 0 } for i := 0; i \u0026lt; rows; i++ { for j := 0; j \u0026lt; cols; j++ { if grid[i][j] == '1' { que.Push(i) que.Push(j) grid[i][j] = '0' for !que.Empty() { x = que.Front().(int)//因为储存的是坐标，所以是int，这里要强制转化，因为que.Front()返回的是interface{}类型 que.Pop() y = que.Front().(int) que.Pop() for k := 0; k \u0026lt; 4; k++ { xx = x + dx[k] yy = y + dy[k] if xx \u0026lt; 0 || xx \u0026gt;= rows || yy \u0026lt; 0 || yy \u0026gt;= cols { continue } if grid[xx][yy] == '1' { grid[xx][yy] = '0' que.Push(xx) que.Push(yy) } } } count++ } } } return count }  ","date":1544358553,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1544358553,"objectID":"4b86190f28bb450e33b7b452e7826fa4","permalink":"https://RyanAdex.github.io/2018/12/09/queue/","publishdate":"2018-12-09T20:29:13+08:00","relpermalink":"/2018/12/09/queue/","section":"post","summary":"岛屿的个数 给定一个由 \u0026lsquo;1\u0026rsquo;（陆地）和 \u0026lsquo;0\u0026rsquo;（水）组成的的二维网格，计算岛屿的数量。一个岛被水","tags":["leetcode","队列","BFS","C++","Go"],"title":"LeetCode 队列与BFS--岛屿的数量","type":"post"},{"authors":null,"categories":[],"content":"前些日子参加了一个叫Advent of Code的编程大赛，每天一道题，快活似神仙。这每道题都有自己的拼图数据输入puzzle input，要做题就需要用到该数据，把数据复制过来感觉又太麻烦，于是就兴起写了一个直接从html读取数据的函数。 其数据如下：\n+12 -10 -4 -8 +18 -1 -13 ...  查看标准库文档，发现net/html包可以做这个功能，其函数如下：\nresp, err := http.Get(\u0026quot;http://example.com/\u0026quot;) if err != nil { // handle error } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ...  然后调试，但并未有相关数据输出，在浏览器中检查元素发现该请求需要带cookie才能正确返回数据。直接使用http.Get()并不带有cookie，所以改用NewRequest使用指定的方法、网址和可选的主题创建并返回一个新的*Request。其函数如下：\nclient := \u0026amp;http.Client{} req, err := http.NewRequest(\u0026quot;GET\u0026quot;, url, nil) if err != nil { log.Fatal(err) } req.Header.Set(\u0026quot;Cookie\u0026quot;, \u0026quot;name=value\u0026quot;) resp, err := client.Do(req) robots, err := ioutil.ReadAll(resp.Body) resp.Body.Close()//必须要关闭Body  用ioutil.ReadAll()返回的是[]byte类型，入需要使用可以先将[]byte转换成string，Go语言初学者都会的类型转换语法：string(b)，Go为了稳定性对于上述方法需要经过一些数据上的复制，一旦数据量过大，这个成本是难以忍受的。 所以为了让Go服帖，我们得用上unsafe包，unsafe包提供一些可以跳过Go语言类型安全限制的操作。看下面代码：\nfunc BytesString(b []byte) string { return *(*string)(unsafe.Pointer(\u0026amp;b)) }  我们取到[]byte的指针，Go会说*byte不是*string，但是我们有外挂unsafe.Pointer，所以Go就通过了，接着你很自在的把*byte转成了*string，因为reflect.StringHeader和reflect.SliceHeader的结构体只相差末尾一个字段。 类似的用法可以看Go语言黑魔法 接着用regexp包正则表达式FindAllString取出匹配的[]string数据使用，然后再用strconv.Atoi()进行转化就可以了。 Day1的题为求和，其代码如下：\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;io/ioutil\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;os\u0026quot; \u0026quot;regexp\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;unsafe\u0026quot; ) func BytesString(b []byte) string {//[]byte 转string return *(*string)(unsafe.Pointer(\u0026amp;b)) } func getPuzzle(url string) string {//从网页抓取数据 client := \u0026amp;http.Client{} req, err := http.NewRequest(\u0026quot;GET\u0026quot;, url, nil) if err != nil { log.Fatal(err) } req.Header.Set(\u0026quot;Cookie\u0026quot;, \u0026quot;session=53616c74...\u0026quot;) resp, err := client.Do(req) robots, err := ioutil.ReadAll(resp.Body) // robots := bufio.NewReader(resp.Body) resp.Body.Close() str := BytesString(robots) // fmt.Printf(\u0026quot;%q\u0026quot;, str) return str // io.Copy(os.Stdout, resp.Body) } func sum(num []int) int { sum := 0 for _, n := range num { sum += n } return sum } func strtoint(str []string) []int {//string转int num := make([]int, len(str)) for i := 0; i \u0026lt; len(str); i++ { flag := str[i][0] chafre, _ := strconv.Atoi(str[i][1:]) switch flag { case '+': num[i] = chafre case '-': num[i] = -chafre } } return num } func main() { change := getPuzzle(\u0026quot;https://adventofcode.com/2018/day/1/input\u0026quot;) re := regexp.MustCompile(\u0026quot;[+|-][0-9]*\u0026quot;)//正则表达式 str := re.FindAllString(change, -1) num := strtoint(str) sum := sum(num) fmt.Printf(\u0026quot;sum is %d\\n\u0026quot;, sum) }  如果有更好的方法，欢迎私信，哈哈哈···\n","date":1543926587,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543926587,"objectID":"94d356670112590754f4cc52c9561bc9","permalink":"https://RyanAdex.github.io/2018/12/04/htmlparse/","publishdate":"2018-12-04T20:29:47+08:00","relpermalink":"/2018/12/04/htmlparse/","section":"post","summary":"前些日子参加了一个叫Advent of Code的编程大赛，每天一道题，快活似神仙。这每道题都有自己的拼图数据输入puzzle input，要做题就","tags":["Go","html","cookie","BytesString"],"title":"go语言带cookie的net客户端请求ii与[]byte转string","type":"post"},{"authors":null,"categories":[],"content":"时值我小病在家休养生息，喜欢跳广场舞的外公来寻求我的帮助，他们跳广场舞是将存有歌曲的U盘插到音响上面，而音响大部分都是只能显示歌曲的索引index，不能直接显示歌曲名，所以为了方便他们会在U盘里面对歌曲进行排序。由于音响是寻址按顺序播放，意思就是在U盘里面的歌曲需要一首一首的按顺序复制过去，而且当对U盘歌曲进行增添的时候又需要按照顺序重新复制一遍，可以说相当麻烦。为了将我从这重复的劳动中解放出来，我用go语言写了一个小工具，本来想着分分钟写完，却没想到踩到了坑。 在os包中有一个Rename()函数具有重命名和移动的功能，其函数如下：\nfunc Rename(oldpath, newpath string) error  Rename修改一个文件的名字，移动一个文件。可能会有一些个操作系统特定的限制。\n在windows系统下面使用该函数，oldpath和newpath在同一个磁盘/卷下面能正常使用，可我需要将音乐移动到U盘上，当使用这个函数的时候出现了：\nThe system cannot move the file to a different disk drive.  搜索Github的issues，发现Rename在windows中不能进行跨磁盘/卷操作。 为了实现跨磁盘/卷操作，一种方法是直接调用windows API，于是在windows api docs中搜索到movefileex()函数能够实现该功能，但是在go语言的syscall包中只有movefile()函数，其函数如下：\nfunc MoveFile(from *uint16, to *uint16) (err error)  实现文件移动的函数可以写成：\nfunc movefile(oldpath, newpath string) error { //跨卷移动 from, err := syscall.UTF16PtrFromString(oldpath) if err != nil { return err } to, err := syscall.UTF16PtrFromString(newpath) if err != nil { return err } return syscall.MoveFile(from, to)//windows API }  当我们读取oldpath目录里面的文件时调用io/ioutil包的ReadDir()函数可按照文件夹内的排序方式批量读入文件名，其函数实现如下：\nfunc filenamelist(filepath string) []string { var list []string rd, err := ioutil.ReadDir(filepath) //遍历目录 if err != nil { log.Fatal(err) } for _, fi := range rd { if fi.IsDir() { fmt.Printf(\u0026quot;[%s]is dir\\n\u0026quot;, fi.Name()) } else { list = append(list, fi.Name()) fmt.Println(filepath + fi.Name()) } } return list//返回一个string数组 }  当然也可以普通方式读入文件名然后用sort包进行排序。 下面是完整代码：\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;io/ioutil\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; \u0026quot;syscall\u0026quot; ) func movefile(oldpath, newpath string) error { //跨卷移动 from, err := syscall.UTF16PtrFromString(oldpath) if err != nil { return err } to, err := syscall.UTF16PtrFromString(newpath) if err != nil { return err } return syscall.MoveFile(from, to)//windows API } func filenamelist(filepath string) []string { var list []string rd, err := ioutil.ReadDir(filepath) //遍历目录 if err != nil { log.Fatal(err) } for _, fi := range rd { if fi.IsDir() { fmt.Printf(\u0026quot;[%s]is dir\\n\u0026quot;, fi.Name()) } else { list = append(list, fi.Name()) fmt.Println(filepath + fi.Name()) } } return list } func movefilelist(oldpath, newpath string) { for _, fi := range filenamelist(oldpath) { //移动目录的所有文件 err := movefile(oldpath+fi, newpath+fi) if err != nil { log.Fatal(err) } fmt.Println(fi + \u0026quot;--Move To --\u0026gt;\u0026quot; + newpath + \u0026quot;--OK!\u0026quot;) } } func main() { movefilelist(os.Args[1], os.Args[2]) }  最后在终端中：\nRyan@DESKTO MINGW64 /Go/test (master) $ go run main.go ~/Desktop/music/ /d/ C:/Users/Ryan/Desktop/music/新建文本文档 (2).txt C:/Users/Ryan/Desktop/music/新建文本文档.txt 新建文本文档 (2).txt--Move To --\u0026gt;D:/--OK! 新建文本文档.txt--Move To --\u0026gt;D:/--OK!  有了这个脚本，我今后终于可以愉快的帮助我外公了。\n转载请注明\n","date":1543382926,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543382926,"objectID":"a137288f40059c00aaaa4b67c9608a21","permalink":"https://RyanAdex.github.io/2018/11/28/filemove/","publishdate":"2018-11-28T13:28:46+08:00","relpermalink":"/2018/11/28/filemove/","section":"post","summary":"时值我小病在家休养生息，喜欢跳广场舞的外公来寻求我的帮助，他们跳广场舞是将存有歌曲的U盘插到音响上面，而音响大部分都是只能显示歌曲的索引in","tags":["Go","windows"],"title":"go语言 os.Rename() cannot move the file to a different disk drive 怎么办","type":"post"},{"authors":null,"categories":null,"content":" In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 \u0026hellip;\nTip 2 \u0026hellip;\n","date":1536422400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1536422400,"objectID":"6a451186c775f5f0adb3a0416d0cb711","permalink":"https://RyanAdex.github.io/tutorial/example/","publishdate":"2018-09-09T00:00:00+08:00","relpermalink":"/tutorial/example/","section":"tutorial","summary":"In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 \u0026hellip;\nTip 2 \u0026hellip;","tags":null,"title":"Example Page","type":"docs"}]